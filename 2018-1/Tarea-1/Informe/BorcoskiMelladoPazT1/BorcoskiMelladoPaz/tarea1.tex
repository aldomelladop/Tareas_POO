\documentclass[letterpaper,10pt]{article}
\usepackage{longtable}
\usepackage{enumerate}
\usepackage{ucs}
\usepackage{multirow}  %%INSTALAR ESTE PAQUETE!!!
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage[right=2.2cm,left=2.2cm,top=2.2cm,bottom=2.2cm,headsep=1.2cm,footskip=1.2cm]{geometry}
\usepackage{fancyhdr}
\usepackage{fancybox} 
\usepackage{graphicx,tabularx,latexsym}
\usepackage{amsthm,amsmath,amssymb,amsfonts}
\usepackage{booktabs}
\usepackage{tabulary}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{float}
\usepackage{caption}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[pdftex]{hyperref}
%\usepackage{ragged2e}
\hypersetup
	{
	bookmarks=true, 
	unicode=true,
	pdftitle= Tarea N°1 , 
	pdfauthor="{Aldo Mellado Opazo, Nicolás Borcoski, Esteban Paz}", 
	pdfsubject= Programación Orientada al Objeto, 
	pdfnewwindow=true, 
	colorlinks=true, 
	linkcolor=black,
        linktocpage,
            linkcolor=blue,
            anchorcolor=red,
            citecolor=green,
            filecolor=blue,
            menucolor=blue,
            pagecolor=blue,
            urlcolor=blue,
	urlcolor=blue  
	}

\makeindex
\def\figcapskip{1pt}
\def\figtopskip{1pt}
\def\figbottomskip{1pt}
\def\figcapmargin{1pt}
\def\figfarskip{1pt}


\pagestyle{fancy}
 \lhead{Tarea N°1} 
 \rhead{{Programación Orientada al Objeto }} 
 \lfoot{}
 \cfoot{}
 \rfoot{\thepage} 

% ***********************************************************************************
\begin{document}



\renewcommand{\figurename}{\textbf{Fig.}}
\renewcommand{\tablename}{\textbf{Tabla}}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\fontsize{7}{9}\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

% *************************************************************************************

\begin{titlepage}
\hspace{-1cm} \includegraphics[width=1.5cm]{./imagenes/logo}
  \begin{tabular}{l}
  \begin{small} \sc Departamento de Ingeniería Eléctrica \end{small}\\
 \begin{small} \sc Facultad de Ingeniería \end{small}\\  
 \begin{small} \sc Universidad de Concepción \end{small}\\ 
 \begin{small} \sc Concepción, Chile. \end{small}\\                 

  \vspace*{1.5cm}\mbox{}
  \end{tabular}
  %\bigskip

  \vspace*{1.5 in}

\begin{center}
\huge{{\Huge I}nforme Tarea {\Huge N°1}\\}
%\Large{Mediciones Básicas}\\
\vspace{0.3cm}
\vspace{0.5cm}
{\normalsize \hspace{-0.9cm}\textit{Profesor: Mario Medina C. }}\\[0.3cm] 
{\normalsize \textit{Ayudante: Diego Ramírez V.}}\\[0.3cm] 
{\normalsize \hspace{-1cm}\itshape{Alumnos: Nicolás Borcoski S.\\ Aldo Mellado O.\\
\vspace{-0.2cm} \hspace{-0.2cm}Esteban Paz F.}}\\[0.2cm] 
{\normalsize \textit{7 de mayo de 2018.}}
\end{center}

\vspace{7.5cm}
\begin{center}
\large{Programación Orientada al Objeto}\\
Ingeniería Civil en Telecomunicaciones
\end{center}
\end{titlepage}


%-----------------------------------------------------------------------------------------------
%----.------------------------------------------------------------------------------------------

\newpage
\setcounter{page}{0}
\thispagestyle{empty}
\tableofcontents


%-----------------------------------------------------------------------------------------------
%----.------------------------------------------------------------------------------------------
%----.------------------------------------------------------------------------------------------
\newpage
\setcounter{page}{1}

\section{Generando la secuencia de Fibonacci}\label{Generando la secuencia de Fibonacci}

Para el problema 1 de esta tarea, se necesita generar una secuencia de Fibonacci, la cuál es una sucesión de números naturales que comienza con los números 0 y 1 y a partir de estos, los siguientes términos \textit{son la suma de los dos anteriores.}\\

%A los elementos de esta sucesión se les conoce como \textbf{Números de Fibonacci} y se encuentra en numerosas aplicaciones en el área de las ciencias de la computación, matemática y teoría de juegos. Sin embargo, es en la naturaleza donde más se aprecia su forma, pues, se encuentra en forma de configuraciones biológicas en las ramas de los árboles, en las flores de alcachofas y girasoles, además de la de las piñas de las coníferas, además de encontrarse en la configuración de la estructura en espiral del caparazón de algunos moluscos.\\

Para el caso particular de este problema, se pedía consultar el índice en el cual, la sucesión de Fibonacci alcanza los 1000 dígitos.\\

%\begin{figure}[h!]
%\centering
%\includegraphics[scale=0.3]{./imagenes/fibonacci}
%\caption{Representación sucesión Fibonacci}
%\label{fig:1}
%\end{figure}

\subsection*{Procedimiento}\label{Procedimiento}

La lógica a utilizar en la resolución de este problema, fue en primera instancia, la de resolver una suma utilizando listas, eso, para poder generar los valores de la sucesión. Luego, debíamos poder almacenar en una lista, el valor actual y el anterior  en dos listas distintas, en la cual, a la siguiente iteración, el valor "actual" pasara a ser el anterior. Tal y cual se define la sucesión.

\begin{equation}
F_n  = F_{n-1} + F_{n-2}
\label{eq:1}
\end{equation}

Tal que para la segunda iteración.

\begin{align*}
L1  = F_{n-1} \ \ ;  \ L2  = F_{n-2}
\end{align*}

Entendido lo anterior, se necesitaba poder establecer una condición necesaria, que permitiera una vez alcanzada la cantidad de dígitos necesaria, se detuviera. Para ello se introduce la variable len2, que es la que representa el largo de la lista que contendrá finalmente al número de la sucesión que alcanza los 1000 dígitos.\\

Luego, se tiene que para iniciarlizar los valores, pues en este caso se trata del Fibonacci(1), se debía introducir, como primer elemento a cada lista un valor igual a 1, lo que se hace con $\texttt{L1.push\_back(1)}$ y $\texttt{L2.push\_back(1)}$. Hecho esto, definida la condición de detención, se deben definir dos contadores, uno que me servirá de condición y otro que me entregará información respecto del índice, el cual está asociado al número de iteraciones del ciclo while, en que alcance la cantidad de dígitos que se requieren.\\

Ya definida los parámetros que condicionan la operación del código y aquellos que entregarán la información respecto de lo requerido para el problema, se define la suma como una operación iterativa que se vale de valores anteriores y de un carry $\texttt{C}$ que, según sea el caso, valdrá 1 o 0, esto dependerá si existe acarreo desde la unidad a la decena o desde la decena a la centena.\\

Este acarreo al trabajar con listas, implicaba dos cosas, la primera, que existiría eventualmente una iteración en la cual el largo de ambas listas fuera diferente, es decir 13 tuviera largo 2 y 8 tuviera largo 1, de modo que debía hacerse la salvedad y cubrir este caso, esto se logra mediante el if de la línea 38 para el caso del acarreo de unidad a decena, en la cual se hace un $\texttt{push\_back(0)}$ a la vez que se establece como condición adicional, y en la línea 40 para el caso del acarreo de la decena hacia la centena. La posibilidad de que el largo de las listas fuera diferente, se contempló al incluir las lineas 56 hasta 59, pues, una vez hecha la iteración  y recalculado el largo de las listas es que era posible discriminar el largo actual que iban a tener las listas, pudiendo esto pposibilitar o no una nueva iteración con un resultado válido..\\

Finalmente, lo que se detalla en las líneas desde la 51 y hasta la 54, es la copia y borrado del contenido de las listas. Esto se hace precisamente para poder cumplir la condición de fibonacci especificada en la ecuación \ref{eq:1}.

\newpage

\subsection{Código}\label{Codigo_P1}

%\lstset { %
%    language=C++,
%    backgroundcolor=\color{black!5}, % set backgroundcolor
%    basicstyle=\footnotesize,% basic font setting
%	title = \lstname
%	firstline = 2
%	lastline = 23
%}

\lstset{style=mystyle, language= C++}
%\lstinputlisting[language=Python, firstline=37, lastline=45]{./codigos/codigo1.cpp}

\begin{lstlisting}
//Problema 1 Tarea 1

#include <list>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
	int len1,len2,len3,lens=0,cont=0,m=0,aux=0,C=0,i=0,fibo=0,cont1=0; 
    list<int> suma,L1,L2;
    list<int>:: iterator it1,it2,it3;

    //inicializamos la lista en f0 = 1, que corresponden a los primeros valores de la sucesión.
    L1.push_back(1); L2.push_back(1);

	  it1 = L1.begin() ;it2 = L2.begin();
	  len1= L1.size(); len2= L2.size();
	
	/*con los iteradores y sus largos respectivos, definimos la condición de que en el 	ciclo while, 
	apenas se alcance en la lista L2, un largo igual o mayor a los 1000 dígitos se detenga.*/
	
	while(len2<=1000)
	{
        cont = 0; //este contador nos permite usar la condición en la línea 39
        cont1++; //este contador crece conforme se itera en el while
		for(it2=L2.begin(); it2!=L2.end();it2++)
		{
            aux = *it1 + *it2 + C; //definida la suma que da lugar a la sucesión
			m = aux%10;cont++; //operación módulo que permite utilizar un carry en la suma
			if (aux<10) //caso en que no se produce acarreo por no exceder el valor 10
			{suma.push_back(aux);C = 0;} //en este caso, agregamos a la lista el valor resultante de la suma
			
			else //el caso contrario, es que la suma si tenga acarreo
			{suma.push_back(m);C = 1;} //en dicho caso, se usa la operación módulo para agregar el "resto" del módulo 10 y se procede a agregar el carry  C = 1

            if(C==1 && L2.size()==cont)
            {suma.push_back(C);C  = 0;}
            it1++;
    }
        /*Se agrega esta ultima condición para poder cubrir el caso en que haya doble acarreo, unidad-decena y decena-centena, el cual se presenta cuando C = 1 en dos iteraciones*/

    L1.clear(); //una vez hecha la suma, se borran los elementos previos de L1
		L1=L2; //para copiar los nuevos elementos provenientes de los almacenados en L2
		it1 = L1.begin(); 
		len1= L1.size();

		L2.clear(); //Se borran los elementos en L2
		L2 = suma; //para copiar los elementos almacenados en suma
		len2 = L2.size(); //Calculamos el largo para revisar la condición del While
		suma.clear(); 

		if (len2>len1)
		{
        	for (i=0;i<len3;i++)
        	{L1.push_back(0);}
		}
		// Con estas, se cubre la posibilidad de que el largo de los dos elementos sea diferente y debido a esto, no se pueda hacer la suma.
        if (len2>= 1000)
        {cout<<"1000 dígitos alcanzados en el índice:  "<<cont1<<endl;break;}
    }
    return 0;
}

\end{lstlisting}

\newpage

\subsection{Problema}\label{Problema_P1}
\begin{enumerate}[1.]

\item{En este problema, uno de los eventos que se suscita es que dado el acarreo que debe haber entre un dígito los tamaños entre ambas listas, \texttt{L1, L2}, se debía poder llenar el espacio faltante de modo que los tamaños fueran iguales para poder seguir realizando la suma.Este problema se manifestaba cuando, al mostrar los resultados de la suma, en vez de mostrarse un 13, se mostraba en pantalla un \texttt{3}.}\label{p:1}

\item{Asimismo, se tuvo que dado que el acarreo podía producirse no sólo en la unidad hacia la decena, sino también desde la decena y hacia la centena, debía entonces agregarse un espacio en la lista siguiente para que pudiera sumarse el \textit{carry}. Este problema se manifestaba cuando, ya solucionado el problema mencionado en \ref{p:1}., se tenía que para mostrar el número \texttt{21}, este aparecía como un \texttt{111}. Esto debido a que no se estaba haciendo el segundo carry.}\label{p:2}

\item{Tiempo de ejecución demasiado largo}\label{p:3}
\end{enumerate}

\subsection{Solución}\label{Solucion_P1}
\begin{enumerate}[1.]
\item{Respecto de lo mencionado en la sección \ref{p:1} de Problema, se optó por solucionar este problema mediante lo mostrado en las líneas \texttt{35,36} del código, donde se evita así que el carry resultante del overflow de la suma anterior, no se pase a la siguiente, es decir, de este modo se evita que en lugar de mostrar un 13, se muestre solo un 3.}

\item{Respecto del punto \ref{p:2}, se tiene que para solucionar este problema, se solucionan en las líneas \texttt{38,39}, puesto que con estas se cubre el doble acarreo en las que se pone como condición de que, si se produce una segunda iteración, acusada por el contador \texttt{cont}, y si además de esto, se da que C = 1  nuevamente, entonces se agrega un cero, para así poder acarrerear}

\item{Se optó por no mostrar los números y solo mostrar el contador final.}

\end{enumerate}

\subsection{Resultados}\label{Resultados_P1}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{./imagenes/res1}
\caption{Resultado contador 1000 dígitos}
\label{fig:2}
\end{figure}

\newpage

\section{Revisando una secuencia Infinita de números}\label{Revisando una secuencia Infinita de numeros}

Para lograr una secuencia lo suficientemente extensa para cumplir con los requerimientos se decidió emplear un vector de enteros, que almacena cada dígito en un espacio de memoria, obteniendo un resultado similar al presentado en el enunciado de la tarea como S.

 $$S =\{123456789101112131415161718192021...\}$$
 
Dentro de esta secuencia, se debía encontrar las ocurrencias, o veces en que dentro de esta se encuentra un número en particular. Se menciona el caso $f(5) = 81$, por el cual se da a  entender que la 5 ocurrencia de 5 es en la posición 81 de la sucesión. Lo anterior se debía realizar para todas las potencias de 3, entre 1 y 9.

\subsection*{Procedimiento}\label{Procedimiento_P2}

\begin{enumerate}[1.]
\item{Primero se genera un vector vacío.}
\item{Se rellena con los dígitos (dig) por separado de cada número (num)}
\item{Para lograr esto, se toma un número y se descompone en cada uno de sus dígitos.}
\item{Cuando este número no puede descomponerse más, es decir, num=0, entonces se procede con el siguiente número. 
\begin{enumerate}[4.1]
\item{Cada uno de los dígitos se va insertando en el vector con la función}
\item{El problema, es que insertaba primero las unidades, decenas,..., etc. Por esta razón se hace  arreglo matemático con los órdenes de iteración  la función $\textit{reverse}$ para obtener lo pedido}
\end{enumerate}}
\item{num=i, para que se vayan iterando todos los números necesarios, a criterio del programador.}
\item{Se obtiene el vector con la secuencia S.}
\item{Para encontrar lo que se pide se debe tener claro que el código debe ser modificado, de a cuerdo al numero pedido.}
\item{Se crean 2 contadores cont1 y cont2, además de un iterador "iter" del vector.}
\item{ Se genera un ciclo while que recorre todo el vector con el iterador.
\begin{enumerate}[9.1]
\item{Se genera un ciclo if que condiciona a que los siguientes n iteradores (para un numero de n dígitos) apunten a los valores pedidos específicamente, es decir, se encuentra un numero dígito a dígito, igualando con iteradores consecutivos.}
\item{Cuando esto ocurre entonces el ciclo if agrega un 1 a cont1, el cual lleva la cuenta de las ocurrencias del numero en cuestión.}
\item{Luego cuando cont1="numero", quiere decir que se llego a lo pedido, pues el numero a ocurrido esa misma cantidad de veces en la secuencia S.}
\item{El contador cont2 por otro lado, lleva la cuenta de cuantas veces a ocurrido el ciclo while, en otras palabras, lleva la cuenta total de espacios que se han revisado en el vector v1, y por lo tanto cont 2 lleva la cuenta del índice en el cual se está.}
\end{enumerate}}
\item{Se imprime en pantalla cont2 y de esa forma se obtiene la posición donde se encuentra la n-sima ocurrencia del número a buscar.}

\item{ \textbf{Ideas no llevadas a cabo}:
	\begin{enumerate}[{11}.1]
	\item{Nos damos cuenta que se piden múltiplos de 3, y estos cuentan con la propiedad de que la suma de sus dígitos}
	\item{También es múltiplo de 3, y de alguna forma, podríamos reducir el largo del vector. El inconveniente de esto es que si eliminabamos los no-múltiplos de 3 se perderían las posiciones}
	\item{Otra idea era insertar los número de por medio iguales y luego los consecutivos entre ellos, es decir:\\
	Insertar 1 1 1 1 1 1 1 1 1 1 1 1 en las posiciones impares, y luego 0 1 2 3 4 5 6 7 8 9 en las pares, para luego obtener 10111213141516171819, pero esto era muy poco eficiente de implementar y se llego a algo mejor.}
	\end{enumerate}}
\end{enumerate}
\newpage

\subsection{Código}\label{Codigo_P2}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}
\lstset{style=mystyle, language= C++}

\begin{lstlisting}
#include <iostream>
#include <vector>
#include <iterator>
#include <list>
#include <algorithm>


using namespace std;

int main()
{
    vector<int> v1; //Se crea un vector de enteros
    int i,num=0,dig;
    for(i=100000000;i>=0;i--)
    {
         while(num!=0)
        {

           dig = num%10;
           v1.push_back(dig); //Se va rellenando el vector con los digitos
           num = num/10;
        }

        num=i;

    }
    reverse(v1.begin(),v1.end());//El vector se invierte, pues estaba al reves por las iteraciones del ciclo for


    int cont1=0,cont2=0;
    vector<int>::const_iterator iter=v1.begin();

       while (iter != v1.end())
        {
            if (*(iter) == 7&&
               *(iter+1) == 7&&
               *(iter+2) == 8&&
               *(iter+3) == 0)
                {
                     cont1++; //cont1: contador que lleva la cuenta de cuantas veces a ocurrido el numero
                }
                cont2++;//cont2:Este contador lleva la cuenta de las veces que ha ocurridd el ciclo


            if(cont1==7780){break;}//Se corta el ciclo en la n-sima aparicion de n
            ++iter;
        }
        cout<<cont2<<"<="<<cont1<<endl;

    return 0;
}
\end{lstlisting}

\subsection{Problema}\label{Problema_P2}

\begin{enumerate}[1.]
\item{Lo anterior se realiza para todas las potencias de 3, entre 1 y 8. En el caso de $3^{9}$ no pudimos encontrar un i suficientemente grande para abarcar más de 1003 ocurrencias de 19683 en índice 131688897 del vector v1. Más allá de eso, nos arrojó error de memoria.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{./imagenes/error}
\caption{Error por falta de memoria}
\label{fig:3}
\end{figure}
}
\end{enumerate}

\subsection{Solución}\label{Solucion_P2}
\begin{enumerate}[1.]
\item{Para realizar la descomposición del entero en sus dígitos y luego almacenarlos por separado en el vector, como también para comparar mediante iteradores los dígitos buscados con las apariciones en el vector ''infinito''  nos inspiramos en el código solución del primer problema del certamen 1 del año 2017 enviado vía INFODA por el profesor.}
\end{enumerate}

\subsection{Resultados}\label{Resultados_P2}

Los resultados se presentan en la siguiente tabla:

\begin{table}[h!]
\begin{center}
\begin{tabular}{|c|c|}
\hline
$n$ & $f(n)$ \\
\hline
$3^{1}$ & 37 \\ \hline
$3^{2}$ & 169 \\ \hline
$3^{3}$ & 2208 \\ \hline
$3^{4}$ & 4725 \\ \hline
$3^{5}$ & 161013 \\ \hline
$3^{6}$ & 926669 \\ \hline
$3^{7}$ & 14199388 \\ \hline
$3^{8}$ & 52481605\\ \hline
\end{tabular}
\end{center}
\end{table}

\end{document}
